LEVEL 6 – Penguatan Algoritma

ID:
Di Level 6 ini saya fokus menguatkan dasar algoritma dengan banyak latihan soal mudah seputar array, string, dict/hash map, dan set, sambil mulai membiasakan diri menebak kompleksitas waktu dengan notasi Big‑O secara intuitif. Saya mengulang pemakaian struktur data dasar (operasi tambah/hapus/cari di list, manipulasi string, set untuk hilangkan duplikat, dan dict untuk frekuensi), lalu berlatih pola soal klasik seperti two sum (versi brute force dan hash map), reverse string/list dengan beberapa cara, remove duplicates untuk list terurut/tidak terurut, dan hitung frekuensi elemen. Saya juga membuat beberapa soal ala LeetCode Easy versi sendiri (misalnya cek palindrome, geser nol ke akhir, gabung dua list terurut) dan menyelesaikannya dari brute force sampai versi yang lebih efisien. Sebagai mini “project algoritma”, saya membangun program kecil untuk statistik simpel dari list angka dan analisa teks sederhana (karakter, kata, 5 kata paling sering), lalu merapikan solusinya ke dalam fungsi-fungsi terpisah sambil menandai tiap fungsi dengan perkiraan kompleksitas O(1), O(n), atau O(n²).
​

EN:
In Level 6 I focus on strengthening my algorithm foundations by practicing many easy problems around arrays, strings, dicts/hash maps, and sets, while building an intuitive feel for time complexity using Big‑O notation. I review the main data structures (adding/removing/searching in lists, basic string operations, using sets to remove duplicates, and dicts for frequency counting), then work through classic patterns like two sum (both brute‑force and hash‑map versions), reversing strings/lists in multiple ways, removing duplicates from unsorted and sorted lists, and counting element frequencies. I also design and solve my own Easy‑style problems (such as palindrome checking, moving zeros to the end, and merging two sorted lists), starting with brute‑force ideas and then improving them to more efficient solutions. As a small “algorithm project”, I build simple programs for numeric statistics on a list and basic text analysis (characters, words, and the top 5 most frequent words), and refactor the code into separate functions annotated with approximate complexities like O(1), O(n), or O(n²).
​